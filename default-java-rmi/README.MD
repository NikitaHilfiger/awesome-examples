//TODO: Разобраться с безопасностью (no security manager: RMI class loader disabled)

Разумнее было бы построить проекты таким образом, чтобы общие java-модули (Card и BillingService) были описаны только 
один раз в одном из приложений. Это можно было бы сделать, например, с использованием maven. 
Но в этом случае усложниться процесс описания проектов и, к тому же, (кто знает) будет ли у Вас в 
будущем при разработке собственного проекта доступ к исходным кодам серверного приложения? Возможно, что в Вашем распоряжении будут 
только интерфейсы взаимодействия и структуры объектов.

Заметки:

- Необходим интерфейс, который будет общим(будет присутствовать у обеих сторон)
для клиентской и серверной части(а так же объект данных, который мы будем передавать в аргументы метода).
Его клиент использует для вызова метода на удаленной JVM, а сервер принимает вызов на репликацию этого же интерфейса и передает в свою имплементацию этого интерфейса-> вычисляет -> 
передает результат выполнения обратно
- Интерфейс должен имплементить интерфейс Remote, на сколько я понял, он служит маркером для сервиса регистрации RMI
- Имплементация интерфейса на сервере должна реализовывать UnicastRemoteObject(опять же, на сколько я понял это маркет для реальных исполняемых объектов)
- Конструктор класса UnicastRemoteObject обеспечивает экспорт объекта, чтобы он был доступным для приема удаленных вызовов. Экспорт позволяет удаленному
RMI объекту ожидать соединений с клиентами для осуществления взаимодействия типа "точка-точка" с использованием стандартных соединений через сокеты.
- После RMI объекта(имплементации, сервиса) на сервере у которого клиент, по итогу, будет вызывать метод должен зарегистрироваться в rmiRegistry, к которому в свою очередь будет
обращаться клиент, как я думаю, для получения адреса JVM и отправки сериализованных данных
- Ссылка установления связи с удаленным RMI объектом(имплементацией интерфейса) обычно имеет следующий вид : rmi://host:port/object

И так ключевые моменты: 

- Общий интерфейс к которому будет обращаться клиент и который будет слушать сервер, а затем передавать обработку запроса имплементации этого интерфейса(на клиенте этот интерфейс
будет называться заглушкой, он инкапсулирует упаковку, отправку данных и тд. на сервер, а на сервере такой интерфейс будет называться скелетом, он будет разворачивать запрос. Для
клиента это будет выглядеть как локальный вызов метода, а на сервере, как вызов из локального объекта)
- Общий интерфейс, имплементация этого интерфейса, а так же данные которые мы будем использовать должны имплементить спец. интерфейсы
(Remote - флаг того, что интерфейс используется для RMI взаимодействия к удаленному объекту; 
 UnicastRemoteObject - флаг того, что 
  класс является удаленным объектом, методы которого использует клиент, через Remote интерфейс. Этот флаг используется для экспорта объекта
  (преобразование его в stub) и затем добавление его в Registry, что бы вызовы могли проксироваться ему, через Remote интерфейс, который объект реализиет и rmi библиотека
  сама маппит интерфейс и его реализацию (Remote -> UnicastRemoteObject); Serializable - для объектов, которые мы будем передавать в методы удаленного объекта)
 Serializable для данных)
- Должен присутствовать объект RMI Registry, который располагается, как отдельный сервис на отдельном порту, в котором должны регистрироваться RMI объекты, для того, что бы клиент
смог получить на них ссылку, пример обращения клиента rmi://localhost/BillingService)
- Для успешного доступа необходимо на клиентской и серверной JVM объявить переменную java.rmi.server.codebase и одниковым значением(хостом). Это нужно для java.security.AllPermission;

 